# You are given an integer array nums. You are initially positioned at the array's first index, and each element in the array represents your maximum jump length at that position.

# Return true if you can reach the last index, or false otherwise.

 

# Example 1:

# Input: nums = [2,3,1,1,4]
# Output: true
# Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.
# Example 2:

# Input: nums = [3,2,1,0,4]
# Output: false
# Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.
 

# Constraints:

# 1 <= nums.length <= 104
# 0 <= nums[i] <= 105

# 新しい問題を日本語に翻訳し、Rubyコードで解説付きのソリューションを作成しました。各ステップでの状態がわかるように `puts` で経過を表示しています。詳細な解説については以下に記述します。

# ### 詳細な解説

# #### 問題の概要
# 整数の配列 `nums` が与えられ、あなたは配列の最初のインデックス（位置 `0`）に立っています。各要素 `nums[i]` はその位置からジャンプできる最大の距離を表しています。この問題の目的は、「最初のインデックスから最後のインデックスまで到達できるかどうか」を判定することです。

# #### アルゴリズムの選択
# この問題を解くために、**貪欲法**を用います。貪欲法では、各ステップで到達可能な最大の範囲を追跡し、最適な結果を得るための決定をします。

# #### 解法の考え方
# - 変数 `max_reachable` を使用して、現在までに到達可能な最大のインデックスを追跡します。
# - 配列 `nums` をループし、各位置で「今の位置からジャンプしてどこまで到達できるか」を確認し、その結果を `max_reachable` に更新します。
# - もし現在のインデックス `i` が `max_reachable` を超えている場合、その位置には到達できないことが確定するため `false` を返します。
# - ループをすべて完了した場合、最後のインデックスまで到達可能であるため `true` を返します。

# #### 状態遷移の表示
# プログラムには `puts` 文を使って各ステップごとの状態が表示されるようにしています。例えば、各インデックスで「現在の位置」「ジャンプできる範囲」「最大到達可能インデックス」を表示することで、どのように進んでいるかが確認できます。

# #### 例を使った解説
# 1. **例1**：`nums = [2, 3, 1, 1, 4]`
#    - 最初の位置 `0` から、最大 `2` ステップジャンプできます。そのため、インデックス `1` または `2` に到達できます。
#    - 次にインデックス `1` から `3` ステップジャンプして、最後のインデックス `4` に到達できます。このため、結果は `true` になります。

# 2. **例2**：`nums = [3, 2, 1, 0, 4]`
#    - 最初の位置 `0` から `3` ステップジャンプできます。しかし、どのようにジャンプしてもインデックス `3` に到達し、その位置からは次のインデックスに進むことができません（ジャンプが `0` のため）。そのため、最後のインデックス `4` には到達できず、結果は `false` になります。

# #### コードのポイント
# - **初期化**：
#   - `max_reachable = 0` として、最初に到達可能なインデックスを `0` に設定します。
# - **ループ処理**：
#   - 配列 `nums` を各インデックス `i` について走査します。
#   - 現在のインデックス `i` が `max_reachable` よりも大きい場合、その位置には到達できないことが確定するため、`false` を返します。
#   - 各ステップで、`max_reachable` を `i + nums[i]` の値と比較して更新し、最大の到達可能インデックスを維持します。
# - **結果の判定**：
#   - 最後まで到達可能であれば、`true` を返します。

# #### 計算量
# - **時間計算量**：`O(n)`。配列を1回走査するだけで済むため効率的です。
# - **空間計算量**：`O(1)`。追加の空間をほとんど使用せず、定数サイズの変数のみを使用します。

# このアプローチにより、各位置での到達可能性を常に追跡することで、効率的に最終的な答えを求めることができます。貪欲法は最適な選択を行うため、この問題を非常に効率よく解決することができます。

# 整数の配列 nums が与えられています。あなたは最初、配列の最初のインデックスに位置しており、
# 配列の各要素はその位置での最大ジャンプ長を表しています。
# 最後のインデックスに到達できる場合は true を、そうでなければ false を返してください。

# 例1:
# 入力: nums = [2,3,1,1,4]
# 出力: true
# 説明: インデックス 0 から 1 に1ステップジャンプし、次にインデックス 1 から最後のインデックスまで3ステップジャンプします。

# 例2:
# 入力: nums = [3,2,1,0,4]
# 出力: false
# 説明: どのようにジャンプしてもインデックス 3 に到達しますが、その位置から最後のインデックスに到達することはできません。

def can_jump(nums)
  max_reachable = 0  # 到達可能な最大インデックス

  nums.each_with_index do |jump, i|
    # 現在のインデックスが到達可能か確認
    if i > max_reachable
      puts "到達不可能なインデックス #{i} で停止します。最大到達可能インデックスは #{max_reachable} です。"
      return false
    end
    # 到達可能な最大インデックスを更新
    max_reachable = [max_reachable, i + jump].max
    # 経過表示
    puts "i=#{i}, jump=#{jump}, max_reachable=#{max_reachable}"
  end

  true
end

# テストケース1
puts "テストケース1: nums = [2,3,1,1,4]"
puts "結果: #{can_jump([2,3,1,1,4])}"  # 期待される出力: true

# テストケース2
puts "\nテストケース2: nums = [3,2,1,0,4]"
puts "結果: #{can_jump([3,2,1,0,4])}"  # 期待される出力: false

# 解説:
# この問題は、貪欲法を用いて解決します。
# 変数 `max_reachable` を使って現在到達可能な最大インデックスを追跡します。
# 配列をループして、各位置でジャンプ可能な範囲を確認し、その最大到達可能インデックスを更新します。
# もし現在のインデックスが `max_reachable` を超えると、その位置には到達できないため false を返します。
# 最終的にループを完了すれば、最後のインデックスに到達可能であるため true を返します。

# なぜ max_reachable を使うのか？
# max_reachable は「現在までに到達可能な最大インデックス」を追跡するために使います。この変数が重要な理由は、次のとおりです：

# 各ステップでジャンプできる最大の範囲を追跡する:

# max_reachable は、現在位置からジャンプして到達できる最大のインデックスを表しています。
# 例えば、インデックス i にいて、ジャンプ可能な長さが nums[i] だった場合、インデックス i から到達できる範囲は i + nums[i] です。この範囲を max_reachable として更新していきます。
# 現在位置が到達可能であるかの確認:

# 各ステップで、現在のインデックス i が max_reachable を超えているかどうかを確認します。
# i > max_reachable となると、それ以上進むことができないことが確定します。なぜなら、max_reachable は到達可能な最大インデックスなので、それを超える位置には物理的にジャンプして到達する手段がないからです。
# したがって、その時点で false を返します。
# 最後のインデックスに到達できるかどうか:

# ループを全て完了しても false を返していない場合、つまり、すべてのインデックスが到達可能であった場合は、配列の最後のインデックスにも到達可能です。この場合、true を返します。

### 幅優先探索（BFS: Breadth-First Search）とは？

**幅優先探索（BFS）** は、グラフやツリー構造における探索アルゴリズムの 1 つで、**最短経路の探索**や、特定の条件を満たすノードの探索に適しています。

BFS の基本的な動作原理は、**現在のノードから隣接するノードをすべて調査し、その次に隣接ノードの隣接ノードを調査する**という方法です。これにより、探索は**層（レベル）**ごとに広がり、各層のノードを一通り調査してから次の層に進むことになります。

### BFS の特徴

- **幅広く探索**: BFS は、最初にスタートノードから直接接続されたすべての隣接ノードを探索し、それが終わったら次に隣接ノードの隣接ノードを探索するので、「幅広く」探索します。
- **最短経路が保証される**: BFS は、無向グラフまたはコストが同じ有向グラフにおいて、**最短経路**を見つけることができます。つまり、スタートノードから他のすべてのノードへの最短距離を見つけるのに適しています。
- **キューを使用する**: BFS では、次に探索するノードを管理するために**キュー（FIFO: First In, First Out）**を使用します。これにより、探索を行う順序が保持されます。

### BFS の手順

1. **初期化**:

   - スタートノードを用意し、それを**キュー**に追加する。
   - スタートノードを「訪問済み」としてマークする（通常は訪問済みリスト `visited` を使用）。

2. **探索の開始**:

   - キューから先頭のノードを取り出し（`dequeue`）、そのノードの**隣接ノード**（接続されたノード）をすべて確認する。
   - まだ「未訪問」の隣接ノードがあれば、それらをすべてキューに追加し、訪問済みとしてマークする。

3. **次のノードを探索**:

   - キューが空になるまで 2 の操作を繰り返す。

4. **終了**:
   - 探索したいノードに到達したら、そこで探索を終了する。
   - 目的のノードに到達できない場合は、全ノードの探索が終了するまで続ける。

### BFS を用いた問題の例

ここでは、BFS を用いた典型的な問題を紹介し、どのように BFS が使用されるかを説明します。

#### 例: グラフの最短経路を求める

次のようなグラフがあるとします：

```
  A - B - D
  |     \
  C       E
```

- 各ノードは `A`, `B`, `C`, `D`, `E` という名前のノードです。
- ノード `A` から `E` までの最短経路を見つけたいとします。

##### 手順:

1. **初期化**:

   - スタートノード `A` をキューに追加し、訪問済みリストにマークします。
   - `visited = {A}`
   - キュー: `['A']`

2. **探索開始**:

   - キューの先頭 `A` を取り出し（`dequeue`）。
   - `A` の隣接ノード（`B` と `C`）をキューに追加し、訪問済みにマークします。
   - `visited = {A, B, C}`
   - キュー: `['B', 'C']`

3. **次のノード `B` を探索**:

   - キューの先頭 `B` を取り出し（`dequeue`）。
   - `B` の隣接ノード `D` と `E` をキューに追加し、訪問済みにマークします。
   - `visited = {A, B, C, D, E}`
   - キュー: `['C', 'D', 'E']`

4. **目的のノード `E` に到達**:
   - キューの先頭 `C` を取り出しても、`C` の隣接ノードは `A` だけで、すでに訪問済みです。
   - キューの次のノード `D` も同様に、隣接ノードは `B` ですでに訪問済みです。
   - 最後に `E` に到達したら、探索を終了します。

##### 結果:

- 最短経路は `A -> B -> E` です。

### Ruby を用いた BFS の実装例

以下に、Ruby でのシンプルな BFS アルゴリズムの実装例を示します。この例では、グラフをハッシュマップとして表し、指定したノードからの最短距離を求めます。

```ruby
# BFS を使って、スタートノードからすべてのノードへの最短経路を探索
def bfs_shortest_path(graph, start, goal)
  # キューを初期化（[現在のノード, 経路] の形）
  queue = [[start, [start]]]
  visited = [start]  # 訪問済みノードを記録

  # キューが空になるまで探索を繰り返す
  while !queue.empty?
    # キューの先頭を取り出す
    current_node, path = queue.shift
    puts "現在のノード: #{current_node}, 経路: #{path.join(' -> ')}"

    # ゴールに到達したらその経路を返す
    if current_node == goal
      puts "ゴール #{goal} に到達しました。"
      return path
    end

    # 隣接ノードを探索
    graph[current_node].each do |neighbor|
      unless visited.include?(neighbor)
        visited << neighbor  # 訪問済みに設定
        queue << [neighbor, path + [neighbor]]  # 新しい経路をキューに追加
        puts "隣接ノード #{neighbor} をキューに追加: #{path + [neighbor]}"
      end
    end
  end

  # ゴールに到達できなかった場合
  puts "ゴール #{goal} に到達できませんでした。"
  return nil
end

# グラフの定義（ハッシュで隣接ノードを定義）
graph = {
  'A' => ['B', 'C'],
  'B' => ['A', 'D', 'E'],
  'C' => ['A'],
  'D' => ['B'],
  'E' => ['B', 'D']
}

# スタートノードからゴールノードまでの最短経路を探索
start_node = 'A'
goal_node = 'E'
result = bfs_shortest_path(graph, start_node, goal_node)
puts "最短経路: #{result.join(' -> ')}" if result
```

### 実行結果:

```
現在のノード: A, 経路: A
隣接ノード B をキューに追加: ["A", "B"]
隣接ノード C をキューに追加: ["A", "C"]
現在のノード: B, 経路: A -> B
隣接ノード D をキューに追加: ["A", "B", "D"]
隣接ノード E をキューに追加: ["A", "B", "E"]
現在のノード: C, 経路: A -> C
現在のノード: D, 経路: A -> B -> D
現在のノード: E, 経路: A -> B -> E
ゴール E に到達しました。
最短経路: A -> B -> E
```

### まとめ

BFS は、**幅広く**探索することで、最短経路を見つけるのに適したアルゴリズムです。特にグラフやツリーのレベル構造を持つデータに対して強力です。Ruby の場合、キューの操作は `Array#shift` などで実装できますが、効率の観点では専用のデータ構造（`Queue` クラス）を使用することも考慮するとよいでしょう。

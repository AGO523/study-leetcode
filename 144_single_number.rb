# Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.

# You must implement a solution with a linear runtime complexity and use only constant extra space.

# 非空の整数配列 nums が与えられます。この配列の各要素は2回ずつ現れますが、ただ1つの要素だけが1回しか現れません。この1つの要素を見つけてください。

# 以下の条件を満たす実装を行ってください：

# 計算量が線形時間（O(n)）であること。
# 定数の追加空間しか使用しないこと。


# Example 1:

# Input: nums = [2,2,1]
# Output: 1
# Example 2:

# Input: nums = [4,1,2,1,2]
# Output: 4
# Example 3:

# Input: nums = [1]
# Output: 1
 

# Constraints:

# 1 <= nums.length <= 3 * 104
# -3 * 104 <= nums[i] <= 3 * 104
# Each element in the array appears twice except for one element which appears only once.

def single_number(nums)
  result = 0
  
  nums.each do |num|
    # ペアとなる数は XOR で打ち消し合う:
    # 1 と 1、2 と 2 はそれぞれ XOR すると 0 になります。
    # 順序に依存せずに計算できる:
    # XOR 演算は交換法則が成り立つため、数の順序を入れ替えても結果は同じです。
    # 数と 0 の XOR はその数自身
    result ^= num  # XOR を順に適用
    puts "現在の結果: #{result}（num: #{num}）"
  end
  result
end

puts "\nテストケース2: nums = [4,1,2,1,2]"
puts "結果: #{single_number([4, 1, 2, 1, 2])}"  # 期待される出力: 4


# ### XOR 演算と `^` について

# Ruby の `^` 演算子は **排他的論理和（XOR: Exclusive OR）** を計算するためのものです。これは、2つの数値のビットごとに計算を行います。

# ---

# ### XOR 演算の基本ルール

# XOR 演算は、「2つの値が異なるときに1を返し、同じときは0を返す」という動作をします。

# #### **基本ルール（ビット演算の場合）**
# | 入力A | 入力B | XORの結果 |
# |-------|-------|-----------|
# |   0   |   0   |     0     |
# |   0   |   1   |     1     |
# |   1   |   0   |     1     |
# |   1   |   1   |     0     |

# ---

# ### XOR の特性

# 1. **同じ値を XOR すると0になる**
#    - 例： 5 ^ 5 = 0
#    - 理由: すべてのビットが同じなので、結果はすべて0になります。

# 2. **数値と0を XOR すると、数値そのものになる**
#    - 例： 5 ^ 0 = 5
#    - 理由: 0との XOR は何も変わりません。

# 3. **順序に依存しない（交換法則が成り立つ）**
#    - 例： 5 ^ 3 = 3 ^ 5

# 4. **複数の XOR をグループ化しても結果は同じ（結合法則が成り立つ）**
#    - 例： (5 ^ 3) ^ 2 = 5 ^ (3 ^ 2)

# ---

# ### 実例

# #### **1. XOR の基本動作**
# ```ruby
# puts 10 ^ 12  # 出力: 6
# ```

# 計算の手順:
# 1. 10（2進数で1010） と 12（2進数で1100） をビットごとに XOR します。
# 2. 結果は 6（2進数で0110）。

# ---

# #### **2. 配列内で一意の数を見つける**
# 配列内の数がすべて2回ずつ現れ、1つだけ1回現れる場合、この数を見つけるのに XOR を利用できます。

# - アルゴリズムの動作:
#   - 配列全体を XOR すると、2回現れる数はすべて打ち消され、1回しか現れない数だけが残ります。

# - 実装例:
# ```ruby
# nums = [4, 1, 2, 1, 2]
# result = 0

# nums.each do |num|
#   result ^= num
# end

# puts result  # 出力: 4
# ```

# #### **解説**
# 1. `result` に初期値 0 を設定。
# 2. 配列を順番に走査し、各要素を `result` と XOR。
# 3. 最終的に `result` には一意の数が残ります。

# ---

# #### **3. 値の入れ替え**
# XOR を利用して、追加のメモリを使わずに2つの値を入れ替えることができます。

# - 実装例:
# ```ruby
# a = 5
# b = 7

# a = a ^ b
# b = a ^ b
# a = a ^ b

# puts "a: #{a}, b: #{b}"  # 出力: a: 7, b: 5
# ```

# ---

# #### **4. ビットを反転**
# XOR を使うと、特定のビットを反転できます。

# - 実装例:
# ```ruby
# num = 10  # 2進数で1010
# mask = 2  # 2進数で0010

# result = num ^ mask
# puts result  # 出力: 8（2進数で1000）
# ```

# ---

# ### **まとめ**

# - XOR は2つの数値のビットが「異なる」場合に1を返し、「同じ」場合に0を返します。
# - Ruby では `^` 演算子として使用します。
# - 主に次のような用途で使用されます：
#   1. 配列内の一意の要素を見つける。
#   2. 値をメモリを使わずに入れ替える。
#   3. ビット操作で特定のビットを反転させる。
# - 計算が高速で、メモリの使用量を抑えられるため、アルゴリズムの最適化に有用です。

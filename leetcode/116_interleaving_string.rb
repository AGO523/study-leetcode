# Given strings s1, s2, and s3, find whether s3 is formed by an interleaving of s1 and s2.

# An interleaving of two strings s and t is a configuration where s and t are divided into n and m 
# substrings
#  respectively, such that:

# s = s1 + s2 + ... + sn
# t = t1 + t2 + ... + tm
# |n - m| <= 1
# The interleaving is s1 + t1 + s2 + t2 + s3 + t3 + ... or t1 + s1 + t2 + s2 + t3 + s3 + ...
# Note: a + b is the concatenation of strings a and b.

# 文字列 s1, s2, s3 が与えられたとき、s3 が s1 と s2 の「インターリーブ（交互に並べたもの）」によって作成されたかどうかを判定してください。

# 2つの文字列 s と t のインターリーブとは、s と t をそれぞれ n 個、m 個の部分文字列に分けて、以下のように交互に並べた構成です：

# s = s1 + s2 + ... + sn
# t = t1 + t2 + ... + tm
# 条件として、|n - m| <= 1 を満たし、インターリーブされた結果は次のような形になります：

# s1 + t1 + s2 + t2 + ... または t1 + s1 + t2 + s2 + ...
# つまり、s1 と s2 を交互に並べて s3 を作れるかどうかを調べます。

# 例
# 入力:
# s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
# 出力:
# true
# 説明:
# s1 を "aa" + "bc" + "c" に分割し、s2 を "dbbc" + "a" に分割した結果、次のように交互に並べることができます：
# "aa" + "dbbc" + "bc" + "a" + "c" = "aadbbcbcac"
# よって、s3 はインターリーブによって作成されたため true を返します。


# Example 1:


# Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbcbcac"
# Output: true
# Explanation: One way to obtain s3 is:
# Split s1 into s1 = "aa" + "bc" + "c", and s2 into s2 = "dbbc" + "a".
# Interleaving the two splits, we get "aa" + "dbbc" + "bc" + "a" + "c" = "aadbbcbcac".
# Since s3 can be obtained by interleaving s1 and s2, we return true.
# Example 2:

# Input: s1 = "aabcc", s2 = "dbbca", s3 = "aadbbbaccc"
# Output: false
# Explanation: Notice how it is impossible to interleave s2 with any other string to obtain s3.
# Example 3:

# Input: s1 = "", s2 = "", s3 = ""
# Output: true
 

# Constraints:

# 0 <= s1.length, s2.length <= 100
# 0 <= s3.length <= 200
# s1, s2, and s3 consist of lowercase English letters.

# アプローチと解説
# この問題を解くためには、動的計画法（DP）を使用します。s1 と s2 を使って s3 を作るという問題は、部分的なインターリーブの状態を追跡することで解くことができます。具体的には、s1 の i 番目の文字までと、s2 の j 番目の文字までを使って、s3 の i + j 番目の文字が一致するかを確認しながら進めます。

# DPの状態
# dp[i][j] を「s1 の i 番目までと s2 の j 番目までを使って s3 の i + j 番目までがインターリーブ可能かどうか」と定義します。
# 状態遷移
# 初期状態:
# dp[0][0] = true（s1 も s2 も空文字列なら s3 も空なので true）

# s1 のみを使う場合:
# dp[i][0] = dp[i-1][0] かつ s1[i-1] == s3[i-1] の場合、s1 のみを使って s3 を作ることができる。

# s2 のみを使う場合:
# dp[0][j] = dp[0][j-1] かつ s2[j-1] == s3[j-1] の場合、s2 のみを使って s3 を作ることができる。

# s1 と s2 を使う場合:

# dp[i][j] = dp[i-1][j] かつ s1[i-1] == s3[i+j-1]
# または
# dp[i][j] = dp[i][j-1] かつ s2[j-1] == s3[i+j-1]

def is_interleave(s1, s2, s3)
  return false if s1.length + s2.length != s3.length

  # DPテーブルの初期化
  dp = Array.new(s1.length + 1) { Array.new(s2.length + 1, false) }
  dp[0][0] = true

  # s1 のみ使う場合
  (1..s1.length).each do |i|
    dp[i][0] = dp[i - 1][0] && s1[i - 1] == s3[i - 1]
    puts "dp[#{i}][0] = #{dp[i][0]}"
  end
  
  # s2 のみ使う場合
  (1..s2.length).each do |j|
    dp[0][j] = dp[0][j - 1] && s2[j - 1] == s3[j - 1]
    puts "dp[0][#{j}] = #{dp[0][j]}"
  end
  
  # s1 と s2 を両方使う場合
  (1..s1.length).each do |i|
    (1..s2.length).each do |j|
      dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1])
      puts "dp[#{i}][#{j}] = #{dp[i][j]}"
    end
  end
  
  dp[s1.length][s2.length]
end

# テストケース1
puts "テストケース1: s1 = 'aabcc', s2 = 'dbbca', s3 = 'aadbbcbcac'"
puts "結果: #{is_interleave('aabcc', 'dbbca', 'aadbbcbcac')}"  # 期待される出力: true

# # テストケース2
# puts "\nテストケース2: s1 = 'aabcc', s2 = 'dbbca', s3 = 'aadbbbaccc'"
# puts "結果: #{is_interleave('aabcc', 'dbbca', 'aadbbbaccc')}"  # 期待される出力: false

# `is_interleave` 関数の中の条件式について詳しく説明します。特に、`dp[i][j]` を更新する際の2つの条件を解説します。

# まず、`dp[i][j]` というのは、`s1` の `i` 番目までと `s2` の `j` 番目までの部分を使って、`s3` の `i + j` 番目までがインターリーブ可能かどうかを意味します。これを更新するために、次の2つの条件を考えます。

# ### 1. `dp[i-1][j] && s1[i-1] == s3[i+j-1]`
# この条件は次のことを意味します：

# - **`dp[i-1][j]`**：これは「`s1` の `i-1` 番目まで」と「`s2` の `j` 番目まで」を使って `s3` の `i+j-1` 番目までがインターリーブ可能である」ということです。
#   - もしこれが `true` であれば、`s3` の `i+j` 番目を作るには、`s1` の次の文字を使うことができます。

# - **`s1[i-1] == s3[i+j-1]`**：`s1` の現在の文字（`i` 番目の文字）が `s3` の現在の文字（`i+j` 番目の文字）と一致している必要があります。  
#   - つまり、`s1` の次の文字を `s3` に追加することができるということです。

# この条件を満たす場合、`dp[i][j]` は `true` に更新されます。

# ### 2. `dp[i][j-1] && s2[j-1] == s3[i+j-1]`
# この条件は次のことを意味します：

# - **`dp[i][j-1]`**：これは「`s1` の `i` 番目まで」と「`s2` の `j-1` 番目まで」を使って `s3` の `i+j-1` 番目までがインターリーブ可能である」ということです。
#   - もしこれが `true` であれば、`s3` の `i+j` 番目を作るには、`s2` の次の文字を使うことができます。

# - **`s2[j-1] == s3[i+j-1]`**：`s2` の現在の文字（`j` 番目の文字）が `s3` の現在の文字（`i+j` 番目の文字）と一致している必要があります。  
#   - つまり、`s2` の次の文字を `s3` に追加することができるということです。

# この条件も満たす場合、`dp[i][j]` は `true` に更新されます。

# ### 状態遷移

# #### `dp[i][j]` が `true` になる場合
# - `s1` の `i` 番目の文字を使って `s3` の次の文字を作ることができる場合（`dp[i-1][j]` が `true` で、かつ `s1[i-1] == s3[i+j-1]` が成り立つ場合）。
# - または、
# - `s2` の `j` 番目の文字を使って `s3` の次の文字を作ることができる場合（`dp[i][j-1]` が `true` で、かつ `s2[j-1] == s3[i+j-1]` が成り立つ場合）。

# このどちらかの条件を満たす場合、`dp[i][j]` は `true` に更新されます。つまり、`s1` の `i` 番目までと `s2` の `j` 番目までで `s3` の `i + j` 番目までがインターリーブ可能であることを示しています。

# ### 例を通して理解する

# 例えば、次のような入力があったとします：

# - `s1 = "aabcc"`
# - `s2 = "dbbca"`
# - `s3 = "aadbbcbcac"`

# ここで、`dp[i][j]` の更新を考えます。

# #### 初期状態：
# - `dp[0][0] = true` です。これは、どちらの文字列も空の場合、`s3` も空であるという状態を示しています。

# #### 次の状態：
# - `dp[1][0]` は、`s1[0] == s3[0]` が `true` であれば `true` になります。つまり、`s1` の最初の文字が `s3` の最初の文字と一致しているならば、`dp[1][0] = true` です。
  
#   次に、`dp[0][1]` は、`s2[0] == s3[0]` が `true` であれば `true` になります。

# #### `dp` の更新：
# このようにして、`dp` テーブルを更新していき、最終的に `dp[s1.length][s2.length]` が `true` であれば、`s3` は `s1` と `s2` のインターリーブで構成されていることを意味します。

# ---

# ### まとめ

# `dp[i][j]` を更新するための条件式は、次の2つのいずれかです：

# 1. `s1` の次の文字が `s3` に合致していて、その前までがインターリーブ可能である。
# 2. `s2` の次の文字が `s3` に合致していて、その前までがインターリーブ可能である。

# これにより、`dp` テーブルを動的に更新し、最終的に `s3` が `s1` と `s2` のインターリーブであるかどうかを効率的に判断することができます。

# `dp[i][j] = (dp[i - 1][j] && s1[i - 1] == s3[i + j - 1]) || (dp[i][j - 1] && s2[j - 1] == s3[i + j - 1])` で `-1` が使われている理由は、**配列や文字列のインデックスが 0 から始まる**ためです。

# ### なぜ `-1` が必要なのか？

# `dp[i][j]` というのは、`s1` の最初の `i` 文字と `s2` の最初の `j` 文字を使って、`s3` の最初の `i + j` 文字までを作れるかどうかを表しています。

# ただし、Rubyの配列や文字列のインデックスは `0` から始まるため、`s1[i - 1]` や `s2[j - 1]` を参照することで、`s1` の `i` 番目や `s2` の `j` 番目の文字にアクセスしています。

# ### 詳しい説明

# 1. **`s1[i - 1] == s3[i + j - 1]`**:
#    - `dp[i][j]` の状態を更新するために、`s1` の `i` 番目の文字（`s1[i - 1]`）が、`s3` の `i + j` 番目の文字（`s3[i + j - 1]`）と一致するかどうかを確認します。
#    - ここで、`s1` の `i` 番目の文字は、インデックス `i - 1` で表されるため、`s1[i - 1]` として参照します。同様に、`s3` の `i + j` 番目の文字は `s3[i + j - 1]` で表されます。

# 2. **`s2[j - 1] == s3[i + j - 1]`**:
#    - 同様に、`dp[i][j]` の状態を更新する際に、`s2` の `j` 番目の文字（`s2[j - 1]`）が、`s3` の `i + j` 番目の文字（`s3[i + j - 1]`）と一致するかを確認します。

# ### なぜ `-1` が必要かを例を使って説明

# 例えば、`s1 = "aabcc"`, `s2 = "dbbca"`, `s3 = "aadbbcbcac"` の場合を考えます。

# - `i = 1`, `j = 1` の場合：
#   - `dp[1][1]` を更新するには、`s1[0]`（`s1` の 1番目の文字）と `s3[1]`（`s3` の 2番目の文字）が一致するかどうかを確認します。
#   - このとき、`s1[0] == s3[1]` かどうかを確認する必要があり、`-1` を使わないとインデックスがずれてしまうため正しい比較ができません。

# `-1` がない場合、例えば `dp[1][1]` を更新する際に `s1[1]` や `s3[2]` を参照してしまい、意図した文字列の部分を正しく参照できなくなります。

# ---

# ### まとめ

# `-1` を使用するのは、Rubyのインデックスが0から始まるため、`dp[i][j]` の `i` や `j` が「1番目」「2番目」の文字を参照している場合、実際にはそれぞれ `s1[i - 1]` や `s2[j - 1]` といった形で参照しなければならないからです。

# これにより、インデックスのズレを防ぎ、正しく文字の比較が行えるようにしています。

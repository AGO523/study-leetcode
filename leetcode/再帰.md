再帰（さいき、Recursion）は、ある関数が自分自身を呼び出すことで問題を解決するプログラミングの技法です。再帰は問題を小さな部分に分解し、その小さな部分を再び同じ方法で解決することで、全体の問題を解決します。

https://qiita.com/saka2jp/items/20e6b5e70efa466699b4

### 再帰の基本要素

再帰には、以下の基本要素が必要です。

1. **基本ケース（ベースケース）**:

   - 再帰を終了する条件です。基本ケースがなければ、再帰呼び出しが無限に続いてしまいます。基本ケースは通常、最小の問題サイズに対する解を返します。

2. **再帰呼び出し**:
   - 自分自身を呼び出す部分です。これにより、問題を小さなサブ問題に分解し、そのサブ問題を解決することで全体の問題を解決します。

### 再帰の例

#### 例 1: 階乗の計算

階乗（Factorial）は、ある整数 `n` に対して `n!` を計算するもので、以下のように定義されます：

```
n! = n * (n - 1) * (n - 2) * ... * 1
```

再帰的な定義：

- 基本ケース: `0! = 1`
- 再帰呼び出し: `n! = n * (n - 1)!`

以下に Ruby での再帰的な実装を示します：

```ruby
def factorial(n)
  # 基本ケース
  return 1 if n == 0

  # 再帰呼び出し
  n * factorial(n - 1)
end

# 使用例
puts factorial(5)  # 出力: 120
```

この例では、`factorial(5)` を計算するために `factorial(4)`, `factorial(3)`, ... と再帰的に関数を呼び出し、最終的に `factorial(0)` で 1 を返すことで、各ステップの計算を戻り値として合成していきます。

### 再帰のメリットとデメリット

**メリット**:

- 問題を小さなサブ問題に分割して考えることができ、理解しやすくなる。
- 一部の問題（特に木構造やグラフ探索など）は再帰的な定義が自然であり、コードも簡潔になる。

**デメリット**:

- 再帰呼び出しごとにスタックにフレームが積まれるため、深い再帰ではスタックオーバーフローの危険がある。
- 再帰呼び出しは関数の呼び出しのオーバーヘッドがあるため、ループに比べて効率が悪い場合がある。

### 再帰と再帰の適用例

再帰は多くのアルゴリズムにおいて自然な形で使われます。例えば、以下のような問題があります。

1. **フィボナッチ数列**:
   - フィボナッチ数列の計算は、再帰的に定義できます。
2. **ツリーの遍歴（木の構造の探索）**:

   - ツリー構造のノードを探索する際に、各ノードの子ノードに再帰的にアクセスする。

3. **パーミュテーションと組み合わせの生成**:
   - すべてのパーミュテーション（順列）や組み合わせを生成する際に再帰がよく使われます。

再帰は特に問題を分割して再帰的に解決するのに適した方法であり、正しい基本ケースと再帰呼び出しを設定することで、多くの複雑な問題を簡潔に解決することができます。

`factorial` 関数で `n` が 1 つずつ減っていく理由は、再帰の基本的な特性と、問題をより小さな部分に分解することにあります。具体的には、`factorial` 関数が呼ばれるたびに、`n` が 1 つ減った値で再び `factorial` 関数が呼び出されるからです。

### `factorial` 関数の再帰的な定義

以下に再掲しますが、`factorial` 関数は次のように定義されています。

```ruby
def factorial(n)
  # 基本ケース
  return 1 if n == 0

  # 再帰呼び出し
  n * factorial(n - 1)
end
```

この関数は 2 つの部分から構成されています。

1. **基本ケース**:

   - `n == 0` のときに `1` を返します。この条件により、再帰呼び出しが無限に続くのを防ぎます。

2. **再帰呼び出し**:
   - `factorial(n - 1)` を呼び出します。この部分が `n` を 1 ずつ減らしていく理由です。

### 再帰呼び出しの詳細

`factorial(n)` を計算するために `n * factorial(n - 1)` が呼び出されます。これは、「`n` の階乗は `n` と `n-1` の階乗を掛けたもの」という数学的な性質に基づいています。

例えば `factorial(5)` を計算する場合：

1. **最初の呼び出し**: `factorial(5)`
   - これは `5 * factorial(4)` を意味します。
2. **次の呼び出し**: `factorial(4)`
   - これは `4 * factorial(3)` を意味します。
3. **次の呼び出し**: `factorial(3)`
   - これは `3 * factorial(2)` を意味します。
4. **次の呼び出し**: `factorial(2)`
   - これは `2 * factorial(1)` を意味します。
5. **次の呼び出し**: `factorial(1)`
   - これは `1 * factorial(0)` を意味します。
6. **基本ケース**: `factorial(0)`
   - ここで `1` を返し、再帰呼び出しが終了します。

### なぜ `n` を 1 ずつ減らすのか？

`n` を 1 ずつ減らすのは、問題を段階的に小さくして最終的に基本ケースに到達させるためです。基本ケースに到達すると、関数の呼び出しが止まり、それまでに積み重なった呼び出しの結果が合成されて最終的な解が得られます。

具体的には、`factorial(0)` が `1` を返し、それが `factorial(1)` に戻され、`factorial(1)` は `1 * 1 = 1` を計算して次の呼び出しに戻されます。これが繰り返されて、最終的に `factorial(5)` が `120` を返します。

このように、`n` を 1 ずつ減らすことで再帰的に問題を小さくし、最終的に問題全体を解決することができます。

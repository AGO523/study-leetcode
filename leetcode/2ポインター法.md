2 ポインター法（Two-pointer technique）は、ソートされた配列やリストを効率的に探索するためのアルゴリズム手法です。この手法では、通常、配列の両端に 2 つのポインター（インデックス）を配置し、特定の条件を満たすまでポインターを内側に向かって動かします。この手法は、特に和や差が特定の値に等しいペアやトリプレットを見つける問題において効果的です。

### 2 ポインター法の基本的な流れ

1. **ソート**: 配列をソートします（この手法はソートされた配列に対して適用されるため）。
2. **ポインターの初期化**: 一方のポインターを配列の最初の要素に、もう一方のポインターを配列の最後の要素に設定します。
3. **探索**: ポインターが条件を満たすまで、ポインターを内側に向かって移動させます。

### 2 ポインター法の例

与えられた問題「三つの数の和が 0 となるトリプレットを見つける」の場合、2 ポインター法は次のように適用されます：

1. **配列のソート**: まず、配列をソートします。これにより、2 ポインター法が適用しやすくなります。
2. **ループで固定要素を選ぶ**: 外側のループで一つの要素を選び、それを固定します。
3. **2 ポインターの設定**: 残りの部分で、左端と右端に 2 つのポインターを配置します。
4. **ポインターの移動**: ポインターが条件（和が 0）を満たすまで内側に向かって移動させます。

以下に、この問題に対する 2 ポインター法を使った具体的な実装をコメント付きで示します：

```ruby
class Solution
  def three_sum(nums)
    # 配列をソートする
    nums.sort!
    # 結果を格納するための配列を初期化
    result = []

    # 配列の長さが3未満の場合は空の結果を返す
    return result if nums.length < 3

    # 配列を0からnums.length - 2までループする
    (0...nums.length - 2).each do |i|
      # 同じ値をスキップして重複するトリプレットを避ける
      next if i > 0 && nums[i] == nums[i - 1]

      # 左ポインターと右ポインターを設定
      left = i + 1
      right = nums.length - 1

      # 左ポインターが右ポインターより小さい間ループする
      while left < right
        # 現在の3つの数の合計を計算
        sum = nums[i] + nums[left] + nums[right]

        # 合計が0の場合、結果に追加
        if sum == 0
          result << [nums[i], nums[left], nums[right]]
          left += 1
          right -= 1
          # 重複する値をスキップする
          while left < right && nums[left] == nums[left - 1]
            left += 1
          end
          while left < right && nums[right] == nums[right + 1]
            right -= 1
          end
        # 合計が0より小さい場合、左ポインターを右に移動
        elsif sum < 0
          left += 1
        # 合計が0より大きい場合、右ポインターを左に移動
        else
          right -= 1
        end
      end
    end

    # 結果を返す
    result
  end
end
```

### この実装の詳細

1. **ソート**: 配列をソートすることで、2 ポインター法を適用可能にします。
2. **外側のループ**: 配列の各要素を順に固定し、トリプレットの一つ目の要素として選びます。
3. **内側の 2 ポインター法**:
   - `left` ポインターを固定要素の次の要素に設定。
   - `right` ポインターを配列の最後の要素に設定。
   - ポインターを内側に向かって移動しながら、和が 0 になる組み合わせを探します。
   - 和が 0 の場合、その組み合わせを結果に追加し、重複する組み合わせをスキップします。
   - 和が 0 より小さい場合、左ポインターを右に移動して大きな値を探します。
   - 和が 0 より大きい場合、右ポインターを左に移動して小さな値を探します。

この方法により、効率的に重複しないトリプレットを見つけることができます。

# There is a robot on an m x n grid. The robot is initially located at the top-left corner (i.e., grid[0][0]). The robot tries to move to the bottom-right corner (i.e., grid[m - 1][n - 1]). The robot can only move either down or right at any point in time.

# Given the two integers m and n, return the number of possible unique paths that the robot can take to reach the bottom-right corner.

# The test cases are generated so that the answer will be less than or equal to 2 * 109.

# ロボットが m x n のグリッド上にいます。ロボットは最初、左上隅（grid[0][0]）に位置しています。ロボットは右下隅（grid[m-1][n-1]）に移動しようとしています。ロボットは任意の時点で、下または右にのみ移動できます。

# 2つの整数 m と n が与えられたとき、ロボットが右下隅に到達するためのユニークな経路の数を返してください。

# テストケースは、答えが 2 * 10^9 以下になるように作成されています。

# Example 1:


# Input: m = 3, n = 7
# Output: 28
# Example 2:

# Input: m = 3, n = 2
# Output: 3
# Explanation: From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:
# 1. Right -> Down -> Down
# 2. Down -> Down -> Right
# 3. Down -> Right -> Down
 

# Constraints:

# 1 <= m, n <= 100

# アプローチ
# 基本的な考え方：

# ロボットが位置 grid[i][j] に到達するには、grid[i-1][j] から下に移動するか、grid[i][j-1] から右に移動する方法があります。したがって、grid[i][j] に到達するユニークな経路の数は、grid[i-1][j] と grid[i][j-1] の経路の合計です。
# 動的計画法：

# グリッド上の各セル dp[i][j] に「そのセルに到達するためのユニークな経路の数」を保存します。
# 初期化：左上隅 dp[0][0] からスタートし、そのセルには1つの経路しかありません（そこにロボットが最初にいます）。
# 更新：右または下への移動のみが可能なため、グリッドの各セルは上または左のセルからの経路数を足し合わせて計算します。
# 最終結果：右下隅の dp[m-1][n-1] に到達するための経路数が、全体のユニークな経路の数になります。

def unique_paths(m, n)
  # グリッド上の各セルに到達するための経路の数を記録する dp 配列を初期化
  dp = Array.new(m) { Array.new(n, 0) }
  
  # 初期状態：最初の行と最初の列のセルには1つの経路しかない
  (0...m).each { |i| dp[i][0] = 1 }  # 最初の列は全て 1
  (0...n).each { |j| dp[0][j] = 1 }  # 最初の行も全て 1

  # dp 配列を更新して、各セルに到達するための経路数を計算
  (1...m).each do |i|
    (1...n).each do |j|
      dp[i][j] = dp[i-1][j] + dp[i][j-1]
      puts "dp[#{i}][#{j}] = dp[#{i-1}][#{j}] + dp[#{i}][#{j-1}] -> #{dp[i][j]}"
    end
  end

  # 最終的に右下隅に到達する経路の数を返す
  dp[m-1][n-1]
end

# テストケース1
puts "テストケース1: m = 3, n = 7"
puts "出力: #{unique_paths(3, 7)}"  # 期待される出力: 28

# テストケース2
# puts "\nテストケース2: m = 3, n = 2"
# puts "出力: #{unique_paths(3, 2)}"  # 期待される出力: 3

# この式 `dp[i][j] = dp[i-1][j] + dp[i][j-1]` は、グリッド上でロボットが `i` 行目、`j` 列目のセルに到達するための経路数を計算する動的計画法（DP）の更新式です。

# 具体的には、次のような意味を持っています：

# - `dp[i][j]` は、「グリッドの `i` 行目 `j` 列目に到達するためのユニークな経路数」を表します。
# - `dp[i-1][j]` は、「グリッドの上のセル（`i-1` 行目 `j` 列目）から `i` 行目 `j` 列目に到達する経路数」を意味します。ロボットが**上から下**に移動してくる経路です。
# - `dp[i][j-1]` は、「グリッドの左のセル（`i` 行目 `j-1` 列目）から `i` 行目 `j` 列目に到達する経路数」を意味します。ロボットが**左から右**に移動してくる経路です。

# この式は、「ロボットが下に移動する経路（`dp[i-1][j]`）と、右に移動する経路（`dp[i][j-1]`）の合計が、そのセルに到達する経路の総数になる」という考え方に基づいています。

# ### 具体的な例

# たとえば、次のような `3x3` のグリッドを考えます。

# ```
# (0,0) → (0,1) → (0,2)
#  ↓       ↓       ↓
# (1,0) → (1,1) → (1,2)
#  ↓       ↓       ↓
# (2,0) → (2,1) → (2,2)
# ```

# 初期状態では、次のことがわかります：
# - 左上のセル `dp[0][0]` には1つの経路しかありません（ロボットが最初にいる場所）。
# - 最初の行 `dp[0][j]` では、右にしか移動できないので、どのセルも1つの経路で到達できます。
# - 最初の列 `dp[i][0]` では、下にしか移動できないので、どのセルも1つの経路で到達できます。

# ここで、`dp[1][1]` を計算する場合を考えます。このセルに到達するためには、次の2つの方法があります：
# - **上から来る経路**: `dp[0][1]` から下に移動する経路
# - **左から来る経路**: `dp[1][0]` から右に移動する経路

# したがって、`dp[1][1]` は `dp[0][1]` と `dp[1][0]` を足し合わせたものになります。

# ```
# dp[1][1] = dp[0][1] + dp[1][0]
# ```

# これを適用して全体の `dp` 配列を埋めていくことで、ロボットが各セルに到達するユニークな経路数を効率的に計算できます。

# ### 動的計画法のメリット

# この式を使って動的計画法を適用することで、重複した計算を避けながら効率的にグリッド全体の経路数を計算することができます。各セルの計算は、すでに計算された上と左の経路数を使って更新するため、無駄なく結果を求められます。

# ### まとめ

# - `dp[i][j] = dp[i-1][j] + dp[i][j-1]` は、「上から下に移動する経路」と「左から右に移動する経路」の合計が、セル `dp[i][j]` に到達するユニークな経路数であることを表しています。
# - 動的計画法を使うことで、各セルの到達経路数を効率的に計算できます。

動的計画法（Dynamic Programming, DP）は、問題を**小さな部分問題に分解し、部分問題の解を利用して最終的な問題を解く**手法です。主に、**重複する部分問題**を効率的に解く際に使用されます。

## 動的計画法の基本概念

動的計画法は次の 2 つのステップを含みます。

1. **重複する部分問題の解を保存（メモ化）**：
   - 問題を小さな部分問題に分解し、それぞれの部分問題を一度だけ計算し、その結果を保存します。次回同じ部分問題が必要になったときは、保存していた解を再利用します。
2. **最適部分構造**：
   - 問題の最適解が、その部分問題の最適解から構築できる場合に動的計画法を使用します。つまり、大きな問題の最適解は、小さな問題の最適解の組み合わせで求められます。

### 動的計画法を使う際の特徴

- **部分問題が重複する場合**：
  例えば、フィボナッチ数列の計算では、同じ計算が何度も必要になるため、動的計画法を使うことで効率よく計算できます。

- **再帰的な問題構造**：
  問題を再帰的に分割でき、その分割の結果を使って最終解を導ける場合に動的計画法が有効です。

### 例：フィボナッチ数列の計算

フィボナッチ数列は、次のように定義されます：

```
F(0) = 0
F(1) = 1
F(n) = F(n-1) + F(n-2)  (n >= 2)
```

単純な再帰でこの問題を解くと、同じ計算を何度も行うため効率が悪いです。しかし、動的計画法を使うと、すでに計算した値を保存し、再利用することで効率化できます。

#### 再帰でのフィボナッチ数列

```ruby
def fib(n)
  return n if n < 2
  fib(n - 1) + fib(n - 2)
end
```

この方法では、再帰が深くなり、計算が重複します。例えば、`fib(5)` を計算する際に、`fib(3)` や `fib(4)` が何度も計算されます。

#### 動的計画法を使ったフィボナッチ数列

```ruby
def fib(n)
  return n if n < 2

  # dp配列で計算済みの値を保存
  dp = Array.new(n + 1)
  dp[0] = 0
  dp[1] = 1

  # F(n) を計算
  (2..n).each do |i|
    dp[i] = dp[i - 1] + dp[i - 2]
  end

  dp[n]
end
```

この方法では、`dp` 配列に各部分問題（`F(0)` から `F(n)`）の解を保存しているため、同じ計算を繰り返す必要がなくなります。これにより、計算量は **O(n)** となり、効率が大幅に改善されます。

---

## 動的計画法の手順

1. **問題の分割**：  
   問題を部分問題に分割します。部分問題が独立しており、最終問題を解くためにそれらを組み合わせられる必要があります。

2. **再帰関係の定義**：  
   部分問題間の関係（状態遷移）を定義します。これは通常、数式や再帰的な定義で表現されます。

3. **メモ化またはテーブル構築**：  
   解いた部分問題の結果を保存するために、配列やテーブル（`dp` 配列）を使います。これにより、再度同じ部分問題を解く必要がなくなります。

4. **初期条件の設定**：  
   基本ケースや初期値を設定します。例えば、フィボナッチ数列なら `F(0) = 0` と `F(1) = 1` が初期条件です。

5. **最終解を得る**：  
   最終問題の解は、保存された部分問題の解を組み合わせて得られます。

---

## 動的計画法の例：文字列のデコード

あなたが最初に質問してくれた「数字の文字列をどれだけの方法でデコードできるか？」も動的計画法の一例です。

### 問題を動的計画法で解く手順

1. **部分問題の定義**：
   `dp[i]` を「最初の `i` 文字までの部分文字列がデコードできる方法の数」と定義します。

2. **再帰関係**：

   - `s[i-1]` が 1〜9 の範囲にある場合、`dp[i] += dp[i-1]`
   - `s[i-2..i-1]` が 10〜26 の範囲にある場合、`dp[i] += dp[i-2]`

3. **初期条件**：

   - `dp[0] = 1`（空の文字列は 1 通りのデコード方法がある）
   - `dp[1] = 1`（最初の 1 文字が 0 でない場合、1 通りのデコード方法がある）

4. **結果を返す**：
   `dp[n]` が最終的な答えです。

### デコード問題を動的計画法で解いたコード

```ruby
def num_decodings(s)
  return 0 if s.empty? || s[0] == '0'

  n = s.length
  dp = Array.new(n + 1, 0)
  dp[0] = 1
  dp[1] = 1

  (2..n).each do |i|
    dp[i] += dp[i - 1] if s[i - 1] != '0'  # 1文字でデコードできる場合
    two_digit = s[i - 2..i - 1].to_i
    dp[i] += dp[i - 2] if two_digit >= 10 && two_digit <= 26  # 2文字でデコードできる場合
  end

  dp[n]
end
```

### 計算量の分析

- **時間計算量**: O(n)  
  文字列を 1 回だけ走査しているため、時間は `O(n)` です。
- **空間計算量**: O(n)  
  `dp` 配列を使っているため、空間も `O(n)` です。

---

### 動的計画法を使うべき場合

動的計画法は、以下のような場合に有効です。

1. **部分問題が重複する場合**：
   - 同じ計算を何度も繰り返す必要がある場合、動的計画法を使って効率化できます。
2. **最適部分構造がある場合**：
   - 問題の最適解が、その部分問題の最適解から組み立てられる場合に動的計画法が使えます。

---

### まとめ

- **動的計画法**は、**重複する部分問題**を効率的に解決するための手法です。
- 部分問題を解いて、その結果を再利用することで、計算を効率化できます。
- 例えば、フィボナッチ数列や文字列のデコードのように、再帰的な問題でよく使われます。

もしさらに具体的な例や、より詳細な説明が必要であれば教えてください！

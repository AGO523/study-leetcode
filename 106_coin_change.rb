# You are given an integer array coins representing coins of different denominations and an integer amount representing a total amount of money.

# Return the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.

# You may assume that you have an infinite number of each kind of coin.

# 異なる種類のコインを表す整数配列 coins と、目標の金額 amount が与えられます。これらのコインを使って amount を作るために必要な最小のコイン枚数を求めてください。もし、コインの組み合わせで amount を作ることができない場合は -1 を返してください。

# コインの種類には無限にあると仮定します。



# Example 1:

# Input: coins = [1,2,5], amount = 11
# Output: 3
# Explanation: 11 = 5 + 5 + 1
# Example 2:

# Input: coins = [2], amount = 3
# Output: -1
# Example 3:

# Input: coins = [1], amount = 0
# Output: 0
 

# Constraints:

# 1 <= coins.length <= 12
# 1 <= coins[i] <= 231 - 1
# 0 <= amount <= 104

# この問題は、動的計画法（DP） を使って解くことができます。与えられた amount を作るために、最小のコイン枚数を効率的に計算します。

# アプローチ
# DP配列の初期化：

# dp[i] を「金額 i を作るために必要な最小のコイン枚数」とします。
# 初期値として、dp[0] = 0 とし、残りは 無限大 に設定します（なぜなら、初期状態ではどの金額もまだ作成できていないため）。
# 再帰関係の構築：

# コイン coins[j] を使うことで金額 i を作れる場合、次の状態遷移式を使います：
# css
# コードをコピーする
# dp[i] = min(dp[i], dp[i - coins[j]] + 1)
# これは「i - coins[j] を作るための最小コイン枚数に1枚追加する」という意味です。
# 最終結果の取得：

# dp[amount] が無限大でなければその値を返し、そうでなければ -1 を返します。


def coin_change(coins, amount)
  # dp配列を初期化。最初は全て無限大とし、dp[0] = 0 に設定
  dp = Array.new(amount + 1, Float::INFINITY)
  dp[0] = 0  # 金額0を作るために必要なコインの枚数は0

  puts "初期 dp: #{dp.inspect}"

  # 金額 1 から amount まで順に最小枚数を計算
  # dp[i] を使って「金額 i を作るための最小コイン枚数」を計算する際、dp[i] の値は、前の金額 i - coin（使用したコインを差し引いた値）に基づいて計算
  (1..amount).each do |i|
    coins.each do |coin|
      if i - coin >= 0
        dp[i] = [dp[i], dp[i - coin] + 1].min
        puts "金額 #{i}: コイン #{coin} 使用 → dp[#{i}] = #{dp[i]}"
      end
    end
  end

  # 結果を返す。dp[amount] が無限大の場合は -1
  puts "最終 dp: #{dp.inspect}"
  dp[amount] == Float::INFINITY ? -1 : dp[amount]
end

# テストケース1
puts "テストケース1: coins = [1, 2, 5], amount = 11"
puts "出力: #{coin_change([1, 2, 5], 11)}"  # 期待される出力: 3

# テストケース2
# puts "\nテストケース2: coins = [2], amount = 3"
# puts "出力: #{coin_change([2], 3)}"  # 期待される出力: -1

# # テストケース3
# puts "\nテストケース3: coins = [1], amount = 0"
# puts "出力: #{coin_change([1], 0)}"  # 期待される出力: 0

# 動的計画法での「状態遷移式」は、問題を**部分問題に分解して、その部分問題から最終的な解を構築する**ための式です。状態遷移式が正しく理解できれば、問題をどのように小さな部分に分割して解を導いているかが明確になります。

# ここでは、コイン問題の「状態遷移式」が何を意味しているのか、具体的な例を交えて解説します。

# ---

# ### 状態遷移式の基本

# この問題では、「ある金額 `i` を作るために必要な最小コイン枚数」を求めたいです。そのために、動的計画法では次のような式（状態遷移式）を立てています：

# ```
# dp[i] = min(dp[i - coin] + 1) for each coin
# ```

# ここで `dp[i]` は「金額 `i` を作るために必要な最小コイン枚数」を表しています。

# ### 状態遷移式の解釈

# 1. **`dp[i - coin]` とは？**
#    - 「`i - coin` の金額を作るために必要な最小コイン枚数」です。すでに計算済みの部分問題の解です。
#    - たとえば、もし `i = 7` で `coin = 2` の場合、`dp[7 - 2]` つまり `dp[5]` の値は「金額 5 を作るための最小コイン枚数」を指しています。

# 2. **`+ 1` の意味は？**
#    - 金額 `i` を作るためにコイン `coin` を追加することで、`dp[i - coin]` の最小コイン枚数にもう1枚コインを足して `dp[i]` を計算しています。

# 3. **`min()` とは？**
#    - 複数のコインがある場合、それぞれのコインを使って金額 `i` を作ることが可能です。その中で、最も少ないコイン枚数を選びます。
#    - たとえば、`i = 7` で `coins = [1, 2, 5]` がある場合、`dp[7]` は次のように計算されます：
#      ```
#      dp[7] = min(dp[7 - 1] + 1, dp[7 - 2] + 1, dp[7 - 5] + 1)
#            = min(dp[6] + 1, dp[5] + 1, dp[2] + 1)
#      ```

# ### 具体例で考える

# #### 例：`coins = [1, 2, 5]`, `amount = 7` の場合

# この例で、金額 7 を作るために必要な最小コイン枚数を考えてみましょう。

# 1. **`dp[0] = 0`**  
#    金額 0 を作るにはコインは必要ありません。
   
# 2. **`dp[1]` の計算**  
#    金額 1 を作るために必要な最小枚数は、コイン 1 を1枚使うことで作れます。したがって：
#    ```
#    dp[1] = dp[1 - 1] + 1 = dp[0] + 1 = 1
#    ```

# 3. **`dp[2]` の計算**  
#    金額 2 を作るには、コイン 1 を2枚使うか、コイン 2 を1枚使う方法があります。コイン 2 を使うほうが少ない枚数で済むため：
#    ```
#    dp[2] = min(dp[2 - 1] + 1, dp[2 - 2] + 1)
#          = min(dp[1] + 1, dp[0] + 1)
#          = min(2, 1)
#          = 1
#    ```

# 4. **`dp[3]` の計算**  
#    金額 3 を作るには、コイン 1 を3枚使うか、コイン 2 を1枚とコイン 1 を1枚使う方法があります。したがって：
#    ```
#    dp[3] = min(dp[3 - 1] + 1, dp[3 - 2] + 1)
#          = min(dp[2] + 1, dp[1] + 1)
#          = min(2, 2)
#          = 2
#    ```

# 5. **`dp[4]` の計算**  
#    金額 4 を作るには、コイン 1 を4枚使うか、コイン 2 を2枚使う方法があります。コイン 2 を2枚使うほうが最小です：
#    ```
#    dp[4] = min(dp[4 - 1] + 1, dp[4 - 2] + 1)
#          = min(dp[3] + 1, dp[2] + 1)
#          = min(3, 2)
#          = 2
#    ```

# 6. **`dp[5]` の計算**  
#    金額 5 を作るには、コイン 1 を5枚使うか、コイン 5 を1枚使う方法があります。コイン 5 を1枚使うのが最も少ないため：
#    ```
#    dp[5] = min(dp[5 - 1] + 1, dp[5 - 2] + 1, dp[5 - 5] + 1)
#          = min(dp[4] + 1, dp[3] + 1, dp[0] + 1)
#          = min(3, 3, 1)
#          = 1
#    ```

# 7. **`dp[6]` の計算**  
#    金額 6 を作るには、コイン 1 を6枚使うか、コイン 5 を1枚とコイン 1 を1枚使う方法があります。したがって：
#    ```
#    dp[6] = min(dp[6 - 1] + 1, dp[6 - 2] + 1, dp[6 - 5] + 1)
#          = min(dp[5] + 1, dp[4] + 1, dp[1] + 1)
#          = min(2, 3, 2)
#          = 2
#    ```

# 8. **`dp[7]` の計算**  
#    金額 7 を作るには、コイン 1 を7枚使うか、コイン 5 を1枚とコイン 2 を1枚使う方法があります。したがって：
#    ```
#    dp[7] = min(dp[7 - 1] + 1, dp[7 - 2] + 1, dp[7 - 5] + 1)
#          = min(dp[6] + 1, dp[5] + 1, dp[2] + 1)
#          = min(3, 2, 2)
#          = 2
#    ```

# 金額 7 を作るために必要な最小コイン枚数は `2` 枚です。例えば、コイン 5 を1枚とコイン 2 を1枚使えば金額 7 を作ることができます。

# ---

# ### 状態遷移式のポイント

# - **`dp[i]`**：`i` 金額を作るための最小のコイン枚数を記録する場所。
# - **`dp[i - coin] + 1`**：`i - coin` の金額を作る最小枚数に、コイン `coin` を1枚追加するという考え方。
# - **`min()`**：複数のコインを試し、その中から最小のコイン枚数を選ぶ。

# ### 状態遷移式のまとめ

# 状態遷移式は、与えられた `amount` を作るための部分問題を解いていくための式です。この式を使うことで、各ステップで最適な解（最小のコイン枚数）を見つけ出し、最終的に金額 `i` を作るために必要な最小のコイン枚数を求めることができます。

# ---

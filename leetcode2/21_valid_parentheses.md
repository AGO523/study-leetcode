### ğŸ“ å•é¡Œæ–‡ã®æ—¥æœ¬èªè¨³

æ‹¬å¼§ `'('`, `')'`, `'{'`, `'}'`, `'['`, `']'` ã®ã¿ã‹ã‚‰ãªã‚‹æ–‡å­—åˆ— `s` ãŒä¸ãˆã‚‰ã‚Œã¾ã™ã€‚

ã“ã®æ–‡å­—åˆ—ãŒã€Œ**æ­£ã—ã„ã‹**ï¼ˆvalidï¼‰ã€ã©ã†ã‹ã‚’åˆ¤å®šã—ã¦ãã ã•ã„ã€‚

### âœ… æ­£ã—ã„æ‹¬å¼§ã®å®šç¾©

1. é–‹ãæ‹¬å¼§ã¯ã€**å¯¾å¿œã™ã‚‹é–‰ã˜æ‹¬å¼§**ã§é–‰ã˜ã‚‰ã‚Œã¦ã„ã‚‹ã“ã¨ã€‚
2. æ‹¬å¼§ã¯**æ­£ã—ã„é †åºã§é–‰ã˜ã‚‰ã‚Œã¦ã„ã‚‹**ã“ã¨ã€‚
3. **å„é–‰ã˜æ‹¬å¼§ã«ã¯æ­£ã—ã„é–‹ãæ‹¬å¼§ãŒ 1 ã¤ã ã‘å¯¾å¿œ**ã—ã¦ã„ã‚‹ã“ã¨ã€‚

---

## ğŸ§  è€ƒãˆæ–¹ï¼ˆåˆå¿ƒè€…å‘ã‘ï¼‰

ã“ã®å•é¡Œã¯ã€Œ**ã‚¹ã‚¿ãƒƒã‚¯ï¼ˆStackï¼‰**ã€ã¨ã„ã†ãƒ‡ãƒ¼ã‚¿æ§‹é€ ã‚’ä½¿ã£ã¦è§£ãã®ãŒå®šç•ªã§ã™ã€‚

### Stack ã¨ã¯ï¼Ÿ

- **å¾Œã‹ã‚‰å…¥ã‚ŒãŸã‚‚ã®ã‚’å…ˆã«å–ã‚Šå‡ºã™ï¼ˆLIFOï¼‰** å½¢å¼
- æ‹¬å¼§ã®é–‹ã â†’ é–‰ã˜ã«å¯¾å¿œã•ã›ã‚‹ã®ã«ãƒ”ãƒƒã‚¿ãƒªï¼

---

## ğŸ’¡ ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®æµã‚Œï¼ˆåˆå¿ƒè€…å‘ã‘ï¼‰

1. é–‹ãæ‹¬å¼§ `'('`, `'['`, `'{'` ãŒæ¥ãŸã‚‰ã€**ã‚¹ã‚¿ãƒƒã‚¯ã«å…¥ã‚Œã‚‹**
2. é–‰ã˜æ‹¬å¼§ `')'`, `']'`, `'}'` ãŒæ¥ãŸã‚‰ï¼š

   - ã‚¹ã‚¿ãƒƒã‚¯ãŒç©ºã ã£ãŸã‚‰ `false`ï¼ˆå¯¾å¿œã™ã‚‹é–‹ãæ‹¬å¼§ãŒãªã„ï¼‰
   - ã‚¹ã‚¿ãƒƒã‚¯ã®ä¸€ç•ªä¸Šã®è¦ç´ ã¨**å¯¾å¿œã—ã¦ã„ã‚‹ã‹ç¢ºèª**
   - åˆã£ã¦ã„ãªã‘ã‚Œã° `false`
   - åˆã£ã¦ã„ã‚Œã°ãƒãƒƒãƒ—ï¼ˆã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰å‰Šé™¤ï¼‰

3. æœ€å¾Œã«ã‚¹ã‚¿ãƒƒã‚¯ãŒç©ºã§ã‚ã‚Œã° `true`ã€æ®‹ã£ã¦ã„ãŸã‚‰ `false`

---

## âœ… Ruby ã®å®Ÿè£…ã¨ã‚„ã•ã—ã„è§£èª¬

```ruby
def is_valid(s)
  stack = []
  pairs = {
    ')' => '(',
    ']' => '[',
    '}' => '{'
  }

  s.each_char do |char|
    if pairs.values.include?(char)
      stack.push(char)  # é–‹ãæ‹¬å¼§ãªã‚‰ç©ã‚€
    else
      return false if stack.empty? || stack.pop != pairs[char]
    end
  end

  stack.empty?
end
```

### ğŸ” è§£èª¬

- `pairs` ã§é–‰ã˜æ‹¬å¼§ã«å¯¾å¿œã™ã‚‹é–‹ãæ‹¬å¼§ã‚’ãƒãƒƒãƒ—ã§å®šç¾©ã€‚
- ã‚¹ã‚¿ãƒƒã‚¯ã§é–‹ãæ‹¬å¼§ã‚’è¨˜éŒ²ã€‚
- é–‰ã˜æ‹¬å¼§ãŒå‡ºãŸã¨ãã€ã‚¹ã‚¿ãƒƒã‚¯ã®ä¸€ç•ªä¸Šã¨ãƒãƒƒãƒã—ã¦ã„ã‚‹ã‹ç¢ºèªã€‚
- æœ€å¾Œã« `stack.empty?` ã§ã€ã™ã¹ã¦æ­£ã—ãå¯¾å¿œã—ã¦ã„ãŸã‹åˆ¤æ–­ã€‚

---

## ğŸ§ª TypeScript ç‰ˆ

```ts
function isValid(s: string): boolean {
  const stack: string[] = [];
  const pairs: { [key: string]: string } = {
    ")": "(",
    "]": "[",
    "}": "{",
  };

  for (const char of s) {
    if (Object.values(pairs).includes(char)) {
      stack.push(char);
    } else {
      if (stack.length === 0 || stack.pop() !== pairs[char]) {
        return false;
      }
    }
  }

  return stack.length === 0;
}
```

---

## ğŸ§° Go ç‰ˆ

```go
func isValid(s string) bool {
    stack := []rune{}
    pairs := map[rune]rune{
        ')': '(',
        ']': '[',
        '}': '{',
    }

    for _, char := range s {
        if char == '(' || char == '[' || char == '{' {
            stack = append(stack, char)
        } else {
            if len(stack) == 0 || stack[len(stack)-1] != pairs[char] {
                return false
            }
            stack = stack[:len(stack)-1] // pop
        }
    }

    return len(stack) == 0
}
```

---

## ğŸ¯ ä¾‹ã‚’é€šã—ã¦ç†è§£

| å…¥åŠ›      | ã‚¹ã‚¿ãƒƒã‚¯ã®å‹•ã                 | å‡ºåŠ›    |
| --------- | ------------------------------ | ------- |
| `()`      | `(` â†’ pop with `)`             | `true`  |
| `()[]{} ` | `(` â†’ pop, `[` â†’ pop...        | `true`  |
| `(]`      | `(` â†’ `]` ã§ä¸ä¸€è‡´             | `false` |
| `([)]`    | `(` â†’ `[` â†’ `)` â†’ `]` mismatch | `false` |
| `([])`    | `(` â†’ `[` â†’ pop `]` â†’ pop `)`  | `true`  |
